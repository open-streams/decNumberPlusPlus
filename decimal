/* ------------------------------------------------------------------ */
/* decimal header                                                     */
/* ------------------------------------------------------------------ */
/* Copyright (c) IBM Corporation, 2006.  All rights reserved.         */
/*                                                                    */
/* This software is made available under the terms of the IBM         */
/* alphaWorks License Agreement (distributed with this software as    */
/* alphaWorks-License.txt).  Your use of this software indicates      */
/* your acceptance of the terms and conditions of that Agreement.     */
/*                                                                    */
/* Please send comments, suggestions, and corrections to the author:  */
/*   klarer@ca.ibm.com                                                */
/*   Robert Klarer                                                    */
/* ------------------------------------------------------------------ */

#ifndef _DECBASE_H
#define _DECBASE_H

#include "impl/decCommon.h"
#include "impl/decIO.h"

/* from <fenv.h> */

#define FE_DEC_DOWNWARD          DEC_ROUND_DOWN
#define FE_DEC_TONEAREST         DEC_ROUND_HALF_EVEN
#define FE_DEC_TONEARESTFROMZERO DEC_ROUND_HALF_UP
#define FE_DEC_TOWARDZERO        DEC_ROUND_HALF_DOWN
#define FE_DEC_UPWARD            DEC_ROUND_UP

namespace std {
namespace decimal {

struct decimal32;
struct decimal64;
struct decimal128;

// is_decimal_fp unary type trait:
template <class _T>
struct _Is_decimal_fp_aux {
        static const bool value = false;
};

template <>
struct _Is_decimal_fp_aux<decimal32> {
        static const bool value = true;
};

template <>
struct _Is_decimal_fp_aux<decimal64> {
        static const bool value = true;
};

template <>
struct _Is_decimal_fp_aux<decimal128> {
        static const bool value = true;
};

template <class _T>
struct is_decimal_floating_point
        : std::tr1::integral_constant<bool, _Is_decimal_fp_aux<_T>::value> {
        typedef bool value_type;
        typedef std::tr1::integral_constant<bool, _Is_decimal_fp_aux<_T>::value>
                type;
        operator type() const { return type(); }
};

// promotion traits for binary arithmetic operators:
template <bool _Cond, class _First, class _Second>
struct _IfElse {
        typedef _First type;
};

template <class _First, class _Second>
struct _IfElse<false, _First, _Second> {
        typedef _Second type;
};

// The primary template will match only if _LHS is an integral type.
template <class _LHS, class _RHS>
struct _PromotionTraits {
        typedef _RHS type;
};

template <class _RHS>
struct _PromotionTraits<decimal32, _RHS> {
        typedef typename _IfElse<_Is_decimal_fp_aux<_RHS>::value,
                                 _RHS, decimal32>::type type;
};

template <class _RHS>
struct _PromotionTraits<decimal128, _RHS> {
        typedef decimal128 type;
};

template <class _RHS>
struct _PromotionTraits<decimal64, _RHS> {
        typedef decimal64 type;
};

template <>
struct _PromotionTraits<decimal64, decimal128> {
        typedef decimal128 type;
};

// template constraints:
template <typename _C>
struct _Is_int_or_dec {
        static const bool value = std::tr1::is_integral<_C>::value ||
                                  _Is_decimal_fp_aux<_C>::value;
};

template <bool _B, typename _U = void>
struct _Enable_if_c {
        typedef _U type;
};

template <typename _U>
struct _Enable_if_c<false, _U> {};

template <class _U>
struct _Enable_if_dec :
         public _Enable_if_c<_Is_decimal_fp_aux<_U>::value, _U> {};

template <class _C, typename _U = void>
struct _Enable_if_int_or_dec :
         public _Enable_if_c<_Is_int_or_dec<_C>::value, _U> {};

template <class _LHS, class _RHS, typename _U>
struct _Enable_if_LHS_is_dec_and_RHS_is_int_or_dec :
         public _Enable_if_c<_Is_decimal_fp_aux<_LHS>::value &&
                             _Is_int_or_dec<_RHS>::value,
                             _U> {};

template <typename _LHS, class _RHS, typename _U>
struct _Enable_if_LHS_is_int_and_RHS_is_dec :
         public _Enable_if_c<std::tr1::is_integral<_LHS>::value &&
                             _Is_decimal_fp_aux<_RHS>::value,
                             _U> {};

template <class _LHS, class _RHS>
struct _Arith_LHS_is_dec_and_RHS_is_int_or_dec :
         public _Enable_if_LHS_is_dec_and_RHS_is_int_or_dec<_LHS,
                                                            _RHS, 
                               typename _PromotionTraits<_LHS, _RHS>::type > {};

template <typename _LHS, class _RHS>
struct _Arith_LHS_is_int_and_RHS_is_dec :
         public _Enable_if_LHS_is_int_and_RHS_is_dec<_LHS, _RHS, _RHS> {};

template <typename _LHS, class _RHS>
struct _Assign_LHS_is_int_and_RHS_is_dec :
         public _Enable_if_LHS_is_int_and_RHS_is_dec<_LHS, _RHS, _LHS &> {};

template <class _LHS, class _RHS>
struct _Compare_LHS_is_dec_and_RHS_is_int_or_dec :
         public _Enable_if_LHS_is_dec_and_RHS_is_int_or_dec<_LHS,
                                                            _RHS, bool> {};

template <typename _LHS, class _RHS>
struct _Compare_LHS_is_int_and_RHS_is_dec :
         public _Enable_if_LHS_is_int_and_RHS_is_dec<_LHS, _RHS, bool> {};

template <class _U, typename _RET>
struct _Constrain_if_dec :
         public _Enable_if_c<_Is_decimal_fp_aux<_U>::value, _RET> {};

// FmtTraits specializations
template <>
class _FmtTraits<decimal32> {
public:
        typedef _Context32                         _Context;
        typedef decimal32                          _Fmt;
        typedef _DecBase<_FmtTraits<decimal32> >   _Base;
        typedef _DecBase<_FmtTraits<decimal32> > * _BasePtr;

        static void _FromNumber(_BasePtr _Tgt, const _DecNumber & _Src)
                {
                _Context _Ctxt;
                _Src._ToDecimal32(_Tgt, &_Ctxt);
                }

        static void _FromNumber(_BasePtr _Tgt, const _DecNumber & _Src,
                                _Context * _Ctxt)
                { _Src._ToDecimal32(_Tgt, _Ctxt); }

        static const uint8_t _Zero[];
        static const uint8_t _Max[];
        static const uint8_t _Min[];
        static const uint8_t _Epsilon[];
        static const uint8_t _Denormalized_min[];
        static const uint8_t _INF[];
        static const uint8_t _NAN[];
        static const uint8_t _SNAN[];

        static const std::size_t _NumBytes = 4UL;
};

template <>
class _FmtTraits<decimal64> {
public:
        typedef _Context64                         _Context;
        typedef decimal64                          _Fmt;
        typedef _DecBase<_FmtTraits<decimal64> >   _Base;
        typedef _DecBase<_FmtTraits<decimal64> > * _BasePtr;

        static void _FromNumber(_BasePtr _Tgt, const _DecNumber & _Src)
                {
                _Context _Ctxt;
                _Src._ToDecimal64(_Tgt, &_Ctxt);
                }

        static void _FromNumber(_BasePtr _Tgt, const _DecNumber & _Src,
                                _Context * _Ctxt)
                { _Src._ToDecimal64(_Tgt, _Ctxt); }

        static const uint8_t _Zero[];
        static const uint8_t _Max[];
        static const uint8_t _Min[];
        static const uint8_t _Epsilon[];
        static const uint8_t _Denormalized_min[];
        static const uint8_t _INF[];
        static const uint8_t _NAN[];
        static const uint8_t _SNAN[];

        static const std::size_t _NumBytes = 8UL;
};

template <>
class _FmtTraits<decimal128> {
public:
        typedef _Context128                         _Context;
        typedef decimal128                          _Fmt;
        typedef _DecBase<_FmtTraits<decimal128> >   _Base;
        typedef _DecBase<_FmtTraits<decimal128> > * _BasePtr;

        static void _FromNumber(_BasePtr _Tgt, const _DecNumber & _Src)
                {
                _Context _Ctxt;
                _Src._ToDecimal128(_Tgt, &_Ctxt);
                }

        static void _FromNumber(_BasePtr _Tgt, const _DecNumber & _Src,
                                _Context * _Ctxt)
                { _Src._ToDecimal128(_Tgt, _Ctxt); }

        static const uint8_t _Zero[];
        static const uint8_t _Max[];
        static const uint8_t _Min[];
        static const uint8_t _Epsilon[];
        static const uint8_t _Denormalized_min[];
        static const uint8_t _INF[];
        static const uint8_t _NAN[];
        static const uint8_t _SNAN[];

        static const std::size_t _NumBytes = 16UL;
};

// base class for decimal types:
template <class _Tr>
class _DecBase {
        typedef typename _Tr::_Fmt   _Derived;
        typedef typename _Tr::_Fmt & _DerivedRef;
        typedef typename _Tr::_Fmt * _DerivedPtr;
public:
        // constants (for <cdecfloat> and <limits>)
        static _Derived _GetMax()
                { return _Derived(_Tr::_Max); }

        static _Derived _GetMin()
                { return _Derived(_Tr::_Min); }

        static _Derived _GetEpsilon()
                { return _Derived(_Tr::_Epsilon); }

        static _Derived _GetDenormalizedMin()
                { return _Derived(_Tr::_Denormalized_min); }

        static _Derived _GetNAN()
                { return _Derived(_Tr::_NAN); }

        static _Derived _GetSNAN()
                { return _Derived(_Tr::_SNAN); }

        static _Derived _GetINF()
                { return _Derived(_Tr::_INF); }

        // conversion operators
        operator long long() const 
                { return _DecNumber(*this)._ToSignedIntegral(); }

        // increment, decrement
        _DerivedRef operator++();
        _Derived    operator++(int);
        _DerivedRef operator--();
        _Derived    operator--(int);

        // compound assignment operators
        template <class _T>
        typename _Enable_if_int_or_dec<_T, _DerivedRef>::type
        operator+=(_T _R)
                {
                typedef _DecNumber::_Add _Add;
                _DecNumber::_BinaryOpInPlace<_Add, _Tr>(*this, _R, this);
                return *static_cast<_DerivedPtr>(this);
                }

        _Derived & operator+=(long double _R) { _DEC_NO_MIXED_RADIX; }

        template <class _T>
        typename _Enable_if_int_or_dec<_T, _DerivedRef>::type
        operator-=(_T _R)
                {
                typedef _DecNumber::_Sub _Sub;
                _DecNumber::_BinaryOpInPlace<_Sub, _Tr>(*this, _R, this);
                return *static_cast<_DerivedPtr>(this);
                }

        _Derived & operator-=(long double _R) { _DEC_NO_MIXED_RADIX; }

        template <class _T>
        typename _Enable_if_int_or_dec<_T, _DerivedRef>::type
        operator*=(_T _R)
                {
                typedef _DecNumber::_Mul _Mul;
                _DecNumber::_BinaryOpInPlace<_Mul, _Tr>(*this, _R, this);
                return *static_cast<_DerivedPtr>(this);
                }

        _Derived & operator*=(long double _R) { _DEC_NO_MIXED_RADIX; }

        template <class _T>
        typename _Enable_if_int_or_dec<_T, _DerivedRef>::type
        operator/=(_T _R)
                {
                typedef _DecNumber::_Div _Div;
                _DecNumber::_BinaryOpInPlace<_Div, _Tr>(*this, _R, this);
                return *static_cast<_DerivedPtr>(this);
                }

        _Derived & operator/=(long double _R) { _DEC_NO_MIXED_RADIX; }

        void _FromCoefficientAndExponent(signed long long _Coeff, int _Exp);
        void _FromCoefficientAndExponent(unsigned long long _Coeff, int _Exp);

protected:

        uint8_t _Bytes[_Tr::_NumBytes];

        void _BitwiseInitialize(const uint8_t * _Arr)
                { memcpy(_Bytes, _Arr, _Tr::_NumBytes); }

        void _FromDecimal32 (const decimal32 &  _Q);
        void _FromDecimal64 (const decimal64 &  _Q);
        void _FromDecimal128(const decimal128 & _Q);
        void _FromLongDouble(long double _Src);
        void _FromUnsignedIntegral(unsigned long long _Src);
        void _FromSignedIntegral(long long _Src);
        void _FromString(const std::string & _Str);
};

// increment, decrement
template <class _Tr> inline
typename _DecBase<_Tr>::_DerivedRef _DecBase<_Tr>::operator++()
        {
        typedef _DecNumber::_Add _Add;
        _DecNumber::_BinaryOpInPlace<_Add, _Tr> (*this, _DecNumber(1), this);
        return *this;
        }

template <class _Tr> inline
typename _DecBase<_Tr>::_Derived _DecBase<_Tr>::operator++(int)
        {
        typedef _DecNumber::_Add _Add;
        _DecBase<_Tr> _Tmp(*this);
        _DecNumber::_BinaryOpInPlace<_Add, _Tr> (*this, _DecNumber(1), this);
        return _Tmp;
        }

template <class _Tr> inline
typename _DecBase<_Tr>::_DerivedRef _DecBase<_Tr>::operator--()
        {
        typedef _DecNumber::_Sub _Sub;
        _DecNumber::_BinaryOpInPlace<_Sub, _Tr> (*this, _DecNumber(1), this);
        return *this;
        }

template <class _Tr> inline
typename _DecBase<_Tr>::_Derived _DecBase<_Tr>::operator--(int)
        {
        typedef _DecNumber::_Sub _Sub;
        _DecBase<_Tr> _Tmp(*this);
        _DecNumber::_BinaryOpInPlace<_Sub, _Tr> (*this, _DecNumber(1), this);
        return _Tmp;
        }

// decimal arithmetic type decimal32
class decimal32 : public _DecBase<_FmtTraits<decimal32> > {
        friend class _DecBase<_FmtTraits<decimal32> >;
public:
        // constructors, assignment, and destructor
        decimal32()
                { _BitwiseInitialize(_Tr::_Zero); }

        decimal32(const decimal32 & _L)
                { _BitwiseInitialize(_L._Bytes); }

        decimal32 & operator=(decimal32 _L)
                {
                if(&_L != this)
                        { _BitwiseInitialize(_L._Bytes); }
                return *this;
                }

        ~decimal32() { }

        decimal32(const char * _Str)
                { _FromString(std::string(_Str)); }

        decimal32(std::string _Str)
                { _FromString(_Str); }

        explicit decimal32(float _Q)
                { _FromLongDouble(_Q); }

        explicit decimal32(double _Q)
                { _FromLongDouble(_Q); }

        explicit decimal32(long double _Q)
                { _FromLongDouble(_Q); }

        decimal32(decimal64 _Q);
        decimal32(decimal128 _Q);

        decimal32(int _I)
                { _FromSignedIntegral(_I); }

        decimal32(unsigned int _I)
                { _FromUnsignedIntegral(_I); }

        decimal32(long _I)
                { _FromSignedIntegral(_I); }

        decimal32(unsigned long _I)
                { _FromUnsignedIntegral(_I); }

        decimal32(long long _I)
                { _FromSignedIntegral(_I); }

        decimal32(unsigned long long _I)
                { _FromUnsignedIntegral(_I); }

private:
        typedef _FmtTraits<decimal32> _Tr;

        decimal32(const uint8_t * _Arr)
                { _BitwiseInitialize(_Arr); }
};

inline long double decimal32_to_long_double(decimal32 _D)
        { return _DecNumber(_D)._ToLongDouble(); }

inline long double decimal_to_long_double(decimal32 _D)
        { return decimal32_to_long_double(_D); }

inline decimal32 make_decimal32(long long _Coeff, int _Exp)
        {
        decimal32 _Ret;
        _Ret._FromCoefficientAndExponent(_Coeff, _Exp);
        return _Ret;
        }

inline decimal32 make_decimal32(unsigned long long _Coeff, int _Exp)
        {
        decimal32 _Ret;
        _Ret._FromCoefficientAndExponent(_Coeff, _Exp);
        return _Ret;
        }

// input/output
template <class _CharType, class _CharTraits> inline
std::basic_istream<_CharType, _CharTraits> & operator>>(
                std::basic_istream<_CharType, _CharTraits> & _Is,
                decimal32 & _V) 
        {
        return _Extractor<_CharType, _CharTraits,
                          _FmtTraits<decimal32> >(_Is, _V);
        }

template <class _CharType, class _CharTraits> inline
std::basic_ostream<_CharType, _CharTraits> & operator<<(
                std::basic_ostream<_CharType, _CharTraits> & _Os,
                decimal32 _V)
        {
        return _Inserter(_Os, _V);
        } 

// decimal arithmetic type decimal64
class decimal64 : public _DecBase<_FmtTraits<decimal64> > {
        friend class _DecBase<_FmtTraits<decimal64> >;
public:
        // constructors, assignment, and destructor
        decimal64()
                { _BitwiseInitialize(_Tr::_Zero); }

        decimal64(const decimal64 & _L)
                { _BitwiseInitialize(_L._Bytes); }

        decimal64 & operator=(decimal64 _L)
                {
                if(&_L != this)
                        { _BitwiseInitialize(_L._Bytes); }
                return *this;
                }

        ~decimal64() { }

        decimal64(const char * _Str)
                { _FromString(std::string(_Str)); }

        decimal64(std::string _Str)
                { _FromString(_Str); }

        explicit decimal64(float _Q)
                { _FromLongDouble(_Q); }

        explicit decimal64(double _Q)
                { _FromLongDouble(_Q); }

        explicit decimal64(long double _Q)
                { _FromLongDouble(_Q); }

        decimal64(decimal32 _Q)
                { _FromDecimal32(_Q); }

        decimal64(decimal128 _Q);

        decimal64(int _I)
                { _FromSignedIntegral(_I); }

        decimal64(unsigned int _I)
                { _FromUnsignedIntegral(_I); }

        decimal64(long _I)
                { _FromSignedIntegral(_I); }

        decimal64(unsigned long _I)
                { _FromUnsignedIntegral(_I); }

        decimal64(long long _I)
                { _FromSignedIntegral(_I); }

        decimal64(unsigned long long _I)
                { _FromUnsignedIntegral(_I); }

private:
        typedef _FmtTraits<decimal64> _Tr;

        decimal64(const uint8_t * _Arr)
                { _BitwiseInitialize(_Arr); }
};

inline long double decimal64_to_long_double(decimal64 _D)
        { return _DecNumber(_D)._ToLongDouble(); }

inline long double decimal_to_long_double(decimal64 _D)
        { return decimal64_to_long_double(_D); }

inline decimal64 make_decimal64(long long _Coeff, int _Exp)
        {
        decimal64 _Ret;
        _Ret._FromCoefficientAndExponent(_Coeff, _Exp);
        return _Ret;
        }

inline decimal64 make_decimal64(unsigned long long _Coeff, int _Exp)
        {
        decimal64 _Ret;
        _Ret._FromCoefficientAndExponent(_Coeff, _Exp);
        return _Ret;
        }

// input/output
template <class _CharType, class _CharTraits> inline
std::basic_istream<_CharType, _CharTraits> & operator>>(
                std::basic_istream<_CharType, _CharTraits> & _Is,
                decimal64 & _V) 
        {
        return _Extractor<_CharType,
                          _CharTraits, _FmtTraits<decimal64> >(_Is, _V);
        }

template <class _CharType, class _CharTraits> inline
std::basic_ostream<_CharType, _CharTraits> & operator<<(
                std::basic_ostream<_CharType, _CharTraits> & _Os,
                decimal64 _V)
        {
        return _Inserter(_Os, _V);
        } 

// decimal arithmetic type decimal128
class decimal128 : public _DecBase<_FmtTraits<decimal128> > {
        friend class _DecBase<_FmtTraits<decimal128> >;
public:
        // constructors, assignment, and destructor
        decimal128()
                { _BitwiseInitialize(_Tr::_Zero); }

        decimal128(const decimal128 & _L)
                { _BitwiseInitialize(_L._Bytes); }

        decimal128 & operator=(decimal128 _L)
                {
                if(&_L != this)
                        { _BitwiseInitialize(_L._Bytes); }
                return *this;
                }

        ~decimal128() { }

        decimal128(const char * _Str)
                { _FromString(std::string(_Str)); }

        decimal128(std::string _Str)
                { _FromString(_Str); }

        explicit decimal128(float _Q)
                { _FromLongDouble(_Q); }

        explicit decimal128(double _Q)
                { _FromLongDouble(_Q); }

        explicit decimal128(long double _Q)
                { _FromLongDouble(_Q); }

        decimal128(decimal32 _Q)
                { _FromDecimal32(_Q); }

        decimal128(decimal64 _Q)
                { _FromDecimal64(_Q); }

        decimal128(int _I)
                { _FromSignedIntegral(_I); }

        decimal128(unsigned int _I)
                { _FromUnsignedIntegral(_I); }

        decimal128(long _I)
                { _FromSignedIntegral(_I); }

        decimal128(unsigned long _I)
                { _FromUnsignedIntegral(_I); }

        decimal128(long long _I)
                { _FromSignedIntegral(_I); }

        decimal128(unsigned long long _I)
                { _FromUnsignedIntegral(_I); }

private:
        typedef _FmtTraits<decimal128> _Tr;

        decimal128(const uint8_t * _Arr)
                { _BitwiseInitialize(_Arr); }
};

// out-of-line-constructors
inline decimal32::decimal32(decimal64 _Q)
        { _FromDecimal64(_Q); }
inline decimal32::decimal32(decimal128 _Q)
        { _FromDecimal128(_Q); }
inline decimal64::decimal64(decimal128 _Q)
        { _FromDecimal128(_Q); }

// conversion to and from binary float
inline long double decimal128_to_long_double(decimal128 _D)
        { return _DecNumber(_D)._ToLongDouble(); }

inline long double decimal_to_long_double(decimal128 _D)
        { return decimal128_to_long_double(_D); }

inline decimal128 make_decimal128(long long _Coeff, int _Exp)
        {
        decimal128 _Ret;
        _Ret._FromCoefficientAndExponent(_Coeff, _Exp);
        return _Ret;
        }

inline decimal128 make_decimal128(unsigned long long _Coeff, int _Exp)
        {
        decimal128 _Ret;
        _Ret._FromCoefficientAndExponent(_Coeff, _Exp);
        return _Ret;
        }

// input/output
template <class _CharType, class _CharTraits> inline
std::basic_istream<_CharType, _CharTraits> & operator>>(
                std::basic_istream<_CharType, _CharTraits> & _Is,
                decimal128 & _V) 
        {
        return _Extractor<_CharType, _CharTraits,
                          _FmtTraits<decimal128> >(_Is, _V);
        }

template <class _CharType, class _CharTraits> inline
std::basic_ostream<_CharType, _CharTraits> & operator<<(
                std::basic_ostream<_CharType, _CharTraits> & _Os,
                decimal128 _V)
        {
        return _Inserter(_Os, _V);
        } 

// conversions
template <class _Tr> inline
void _DecBase<_Tr>::_FromDecimal32(const decimal32 & _Q)
        {
        _DecNumber _D(_Q);
        _Tr::_FromNumber(this, _D);
        }

template <class _Tr> inline
void _DecBase<_Tr>::_FromDecimal64(const decimal64 & _Q)
        {
        _DecNumber _D(_Q);
        _Tr::_FromNumber(this, _D);
        }

template <class _Tr> inline
void _DecBase<_Tr>::_FromDecimal128(const decimal128 & _Q)
        {
        _DecNumber _D(_Q);
        _Tr::_FromNumber(this, _D);
        }

template <class _Tr> inline
void _DecBase<_Tr>::_FromLongDouble(long double _Src)
        {
        _DecNumber _Tmp(_Src);
        _Tr::_FromNumber(this, _Tmp);
        }

template <class _Tr> inline
void _DecBase<_Tr>::_FromUnsignedIntegral(unsigned long long _Src)
        {
        _DecNumber _Tmp(_Src);
        _Tr::_FromNumber(this, _Tmp);
        }

template <class _Tr> inline
void _DecBase<_Tr>::_FromSignedIntegral(long long _Src)
        {
        _DecNumber _Tmp(_Src);
        _Tr::_FromNumber(this, _Tmp);
        }

template <class _Tr> inline
void _DecBase<_Tr>::_FromCoefficientAndExponent(signed long long _Coeff,
                                                int _Exp)
        {
        if (_Coeff < 0)
                {
                _DecNumber _Tmp(-_Coeff, _Exp, true);
                _Tr::_FromNumber(this, _Tmp);
                }
        else
                {
                _DecNumber _Tmp(_Coeff, _Exp, false);
                _Tr::_FromNumber(this, _Tmp);
                }
        }

template <class _Tr> inline
void _DecBase<_Tr>::_FromCoefficientAndExponent(unsigned long long _Coeff,
                                                int _Exp)
        {
        _DecNumber _Tmp(_Coeff, _Exp, false);
        _Tr::_FromNumber(this, _Tmp);
        }

template <class _Tr> inline
void _DecBase<_Tr>::_FromString(const std::string & _Str)
        {
        _Derived _Tmp;
        std::stringstream _Iss(_Str);
        _Iss >> _Tmp; 
        *this = _Iss.good() ? _Tmp : _GetNAN();
        }

// free functions for decimal arithmetic classes:
template<class _RHS> inline
typename _Enable_if_dec<_RHS>::type operator+(_RHS _R)
        { return _DecNumber::_UnaryOp<_DecNumber::_Plus,
                                      _FmtTraits<_RHS> >(_R); }

template<class _RHS> inline
typename _Enable_if_dec<_RHS>::type operator-(_RHS _R)
        { return _DecNumber::_UnaryOp<_DecNumber::_Minus,
                                      _FmtTraits<_RHS> >(_R); }

template<class _LHS, class _RHS> inline
typename _Arith_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator+(_LHS _L, _RHS _R)
        {
        typedef _FmtTraits<_RHS> _Tr;
        return _DecNumber::_BinaryOp<_DecNumber::_Add, _Tr>(_L, _R);
        }

template<class _LHS, class _RHS> inline
typename _Arith_LHS_is_dec_and_RHS_is_int_or_dec<_LHS, _RHS>::type
operator+(_LHS _L, _RHS _R)
        {
        typedef _FmtTraits<typename _PromotionTraits<_LHS, _RHS>::type> _Tr;
        return _DecNumber::_BinaryOp<_DecNumber::_Add, _Tr>(_L, _R);
        }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator+(float, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator+(double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator+(long double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator+(_LHS, float)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator+(_LHS, double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator+(_LHS, long double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS, class _RHS> inline
typename _Arith_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator-(_LHS _L, _RHS _R)
        {
        typedef _FmtTraits<_RHS> _Tr;
        return _DecNumber::_BinaryOp<_DecNumber::_Sub, _Tr>(_L, _R);
        }

template<class _LHS, class _RHS> inline
typename _Arith_LHS_is_dec_and_RHS_is_int_or_dec<_LHS, _RHS>::type
operator-(_LHS _L, _RHS _R)
        {
        typedef _FmtTraits<typename _PromotionTraits<_LHS, _RHS>::type> _Tr;
        return _DecNumber::_BinaryOp<_DecNumber::_Sub, _Tr>(_L, _R);
        }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator-(float, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator-(double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator-(long double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator-(_LHS, float)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator-(_LHS, double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator-(_LHS, long double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS, class _RHS> inline
typename _Arith_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator*(_LHS _L, _RHS _R)
        {
        typedef _FmtTraits<_RHS> _Tr;
        return _DecNumber::_BinaryOp<_DecNumber::_Mul, _Tr>(_L, _R);
        }

template<class _LHS, class _RHS> inline
typename _Arith_LHS_is_dec_and_RHS_is_int_or_dec<_LHS, _RHS>::type
operator*(_LHS _L, _RHS _R)
        {
        typedef _FmtTraits<typename _PromotionTraits<_LHS, _RHS>::type> _Tr;
        return _DecNumber::_BinaryOp<_DecNumber::_Mul, _Tr>(_L, _R);
        }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator*(float, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator*(double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator*(long double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator*(_LHS, float)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator*(_LHS, double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator*(_LHS, long double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS, class _RHS> inline
typename _Arith_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator/(_LHS _L, _RHS _R)
        {
        typedef _FmtTraits<_RHS> _Tr;
        return _DecNumber::_BinaryOp<_DecNumber::_Div, _Tr>(_L, _R);
        }

template<class _LHS, class _RHS> inline
typename _Arith_LHS_is_dec_and_RHS_is_int_or_dec<_LHS, _RHS>::type
operator/(_LHS _L, _RHS _R)
        {
        typedef _FmtTraits<typename _PromotionTraits<_LHS, _RHS>::type> _Tr;
        return _DecNumber::_BinaryOp<_DecNumber::_Div, _Tr>(_L, _R);
        }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator/(float, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator/(double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, _RHS>::type operator/(long double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator/(_LHS, float)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator/(_LHS, double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, _LHS>::type operator/(_LHS, long double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator==(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Eq>(_L, _R); }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_dec_and_RHS_is_int_or_dec<_LHS, _RHS>::type
operator==(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Eq>(_L, _R); }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator==(float, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator==(double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator==(long double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator==(_LHS, float)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator==(_LHS, double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator==(_LHS, long double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator!=(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Ne>(_L, _R); }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_dec_and_RHS_is_int_or_dec<_LHS, _RHS>::type
operator!=(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Ne>(_L, _R); }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator!=(float, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator!=(double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator!=(long double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator!=(_LHS, float)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator!=(_LHS, double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator!=(_LHS, long double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator>(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Gt>(_L, _R); }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_dec_and_RHS_is_int_or_dec<_LHS, _RHS>::type
operator>(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Gt>(_L, _R); }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator>(float, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator>(double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator>(long double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator>(_LHS, float)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator>(_LHS, double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator>(_LHS, long double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator<(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Lt>(_L, _R); }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_dec_and_RHS_is_int_or_dec<_LHS, _RHS>::type
operator<(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Lt>(_L, _R); }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator<(float, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator<(double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator<(long double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator<(_LHS, float)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator<(_LHS, double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator<(_LHS, long double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator>=(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Ge>(_L, _R); }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_dec_and_RHS_is_int_or_dec<_LHS, _RHS>::type
operator>=(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Ge>(_L, _R); }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator>=(float, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator>=(double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator>=(long double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator>=(_LHS, float)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator>=(_LHS, double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator>=(_LHS, long double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator<=(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Le>(_L, _R); }

template<class _LHS, class _RHS> inline
typename _Compare_LHS_is_dec_and_RHS_is_int_or_dec<_LHS, _RHS>::type
operator<=(_LHS _L, _RHS _R)
        { return _DecNumber::_Compare<_DecNumber::_Le>(_L, _R); }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator<=(float, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator<=(double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, bool>::type operator<=(long double, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator<=(_LHS, float)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator<=(_LHS, double)
        { _DEC_NO_MIXED_RADIX; }

template<class _LHS> inline
typename _Constrain_if_dec<_LHS, bool>::type operator<=(_LHS, long double)
        { _DEC_NO_MIXED_RADIX; }

// compound assignment operators

template<class _LHS, class _RHS> inline
typename _Assign_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator+=(_LHS & _L, _RHS _R)
        {
        typedef _FmtTraits<_RHS> _Tr;
        typename _Tr::_Fmt _Tmp;
        _DecNumber::_BinaryOpInPlace<_DecNumber::_Add, _Tr>(_L, _R, &_Tmp);
        _L = _Tmp;
        return _L;
        }

template<class _LHS, class _RHS> inline
typename _Assign_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator-=(_LHS & _L, _RHS _R)
        {
        typedef _FmtTraits<_RHS> _Tr;
        typename _Tr::_Fmt _Tmp;
        _DecNumber::_BinaryOpInPlace<_DecNumber::_Sub, _Tr>(_L, _R, &_Tmp);
        _L = _Tmp;
        return _L;
        }

template<class _LHS, class _RHS> inline
typename _Assign_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator*=(_LHS & _L, _RHS _R)
        {
        typedef _FmtTraits<_RHS> _Tr;
        typename _Tr::_Fmt _Tmp;
        _DecNumber::_BinaryOpInPlace<_DecNumber::_Mul, _Tr>(_L, _R, &_Tmp);
        _L = _Tmp;
        return _L;
        }

template<class _LHS, class _RHS> inline
typename _Assign_LHS_is_int_and_RHS_is_dec<_LHS, _RHS>::type
operator/=(_LHS & _L, _RHS _R)
        {
        typedef _FmtTraits<_RHS> _Tr;
        typename _Tr::_Fmt _Tmp;
        _DecNumber::_BinaryOpInPlace<_DecNumber::_Div, _Tr>(_L, _R, &_Tmp);
        _L = _Tmp;
        return _L;
        }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, float>::type operator+=(float &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, double>::type operator+=(double &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, long double>::type
operator+=(long double &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, float>::type operator-=(float &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, double>::type operator-=(double &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, long double>::type
operator-=(long double &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, float>::type operator*=(float &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, double>::type operator*=(double &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, long double>::type
operator*=(long double &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, float>::type operator/=(float &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, double>::type operator/=(double &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

template<class _RHS> inline
typename _Constrain_if_dec<_RHS, long double>::type
operator/=(long double &, _RHS)
        { _DEC_NO_MIXED_RADIX; }

} // namespace decimal
} // namespace std

#endif /* ndef _DECBASE_H */
